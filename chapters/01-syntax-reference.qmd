# Syntax Quick Reference

Tactus `.tac` files are Lua with a small, assignment-based DSL for declaring tools, agents, procedures, and tests.

## File Skeleton

```lua
-- Standard library tools
local done = require("tactus.tools.done")

-- Custom tools (optional)
search = Tool {
  description = "Search the web",
  input = { query = field.string{required = true} },
  function(args) return "..." end
}

-- Agents (assignment-based; tools are variables, not strings)
researcher = Agent {
  provider = "openai",
  model = "gpt-4o-mini",
  system_prompt = "Research {input.topic}. Call done when finished.",
  tools = {search, done}
}

-- Optional: declare the allowed stage names
Stages({"researching", "writing", "complete"})

-- The procedure (unnamed; defaults to "main")
Procedure {
  input = { topic = field.string{required = true} },
  output = { findings = field.string{required = true} },
  function(input)
    Stage.set("researching")
    repeat researcher() until done.called()
    return {findings = done.last_result()}
  end
}

-- Optional: tests (BDD, in-file)
Specifications([[
Feature: Research
  Scenario: Completes
    When the researcher agent takes turns
    Then the done tool should be called
]])
```

## Declarations

### Tools

**Define a Lua function tool:**

```lua
slugify = Tool {
  description = "Convert text to a slug",
  input = { text = field.string{required = true} },
  function(args)
    return string.lower(args.text):gsub("%s+", "-")
  end
}
```

**Import a standard library tool:**

```lua
local done = require("tactus.tools.done")
```

### Agents

```lua
worker = Agent {
  provider = "openai",
  model = {
    name = "gpt-4o",
    temperature = 0.3,
    max_tokens = 1200
  },
  prepare = function()
    return {now = os.date()}
  end,
  system_prompt = [[
Time: {prepared.now}
Task: {input.task}
  ]],
  tools = {done}
}
```

**Callable agent syntax:**

```lua
worker()
worker({message = "Focus on edge cases"})
worker({tools = {}})                -- no tools this turn
worker({tools = {search, done}})    -- restrict tools this turn
```

### Procedures

Procedures are declared with `Procedure { ... }` (unnamed, defaults to `"main"`). Sub-procedures can be assigned to variables:

```lua
summarize = Procedure {
  name = "summarize",
  input = { text = field.string{required = true} },
  output = { summary = field.string{required = true} },
  return_prompt = "Return a short summary.",
  function(input)
    worker({message = input.text})
    return {summary = done.last_result()}
  end
}

Procedure {
  function(input)
    local result = summarize.run({text = "..."})
    return {summary = result.summary}
  end
}
```

### Toolsets

Use a `Toolset` when you want a *bundle* of tools.

```lua
math_tools = Toolset {
  type = "lua",
  tools = {
    {
      name = "add",
      description = "Add numbers",
      parameters = {
        a = {type = "number", required = true},
        b = {type = "number", required = true}
      },
      handler = function(args) return tostring(args.a + args.b) end
    }
  }
}

calculator = Agent { provider = "openai", tools = {math_tools, done} }
```

## Schemas (Input/Output/State)

### Field Types

| Type | Builder |
|------|---------|
| String | `field.string{...}` |
| Number | `field.number{...}` |
| Integer | `field.integer{...}` |
| Boolean | `field.boolean{...}` |
| Array | `field.array{...}` |
| Object | `field.object{...}` |

### Common Field Options

| Option | Meaning |
|--------|---------|
| `required = true` | Must be provided / returned |
| `default = ...` | Optional field with a default |
| `description = "..."` | Shows in CLI/IDE forms and docs |
| `enum = {...}` | Restrict values (strings) |

## Templates

Templates are `{...}` substitutions (re-evaluated before each agent turn).

| Namespace | Example |
|-----------|---------|
| `input` | `{input.topic}` |
| `state` | `{state.count}` |
| `prepared` | `{prepared.file_contents}` |
| `context` | `{context.parent_id}` |
| `env` | `{env.API_KEY}` |

## Control Flow (Lua)

```lua
-- repeat/until is the common “agent loop”
repeat
  worker()
until done.called() or Iterations.exceeded(10)

-- standard Lua conditionals and loops also apply
if Stop.requested() then
  Log.warn("Stopping early", {reason = Stop.reason()})
end
```
